class TupleImpl {
    constructor(first, second) {
        this.first = first;
        this.second = second;
        this.length = 2;
        this[0] = first;
        this[1] = second;
    }
    *[Symbol.iterator]() {
        yield this.first;
        yield this.second;
    }
    toJSON() {
        return this.toArray();
    }
    inspect() {
        return `Tuple(${JSON.stringify(this.first)}, ${JSON.stringify(this.second)})`;
    }
    [Symbol.for('nodejs.util.inspect.custom')](_depth, opts, inspect) {
        return `Tuple(${inspect(this.first, opts)}, ${inspect(this.second, opts)})`;
    }
    toString() {
        return this.inspect();
    }
    fst() {
        return this.first;
    }
    snd() {
        return this.second;
    }
    equals(other) {
        return this.first === other.fst() && this.second === other.snd();
    }
    bimap(f, g) {
        return Tuple(f(this.first), g(this.second));
    }
    mapFirst(f) {
        return Tuple(f(this.first), this.second);
    }
    map(f) {
        return Tuple(this.first, f(this.second));
    }
    reduce(reducer, initialValue) {
        return reducer(initialValue, this.second);
    }
    toArray() {
        return [this.first, this.second];
    }
    swap() {
        return Tuple(this.second, this.first);
    }
    ap(f) {
        return Tuple(this.first, f.snd()(this.second));
    }
    every(pred) {
        return pred(this.first) && pred(this.second);
    }
    some(pred) {
        return pred(this.first) || pred(this.second);
    }
}
TupleImpl.prototype['fantasy-land/equals'] = TupleImpl.prototype.equals;
TupleImpl.prototype['fantasy-land/bimap'] = TupleImpl.prototype.bimap;
TupleImpl.prototype['fantasy-land/map'] = TupleImpl.prototype.map;
TupleImpl.prototype['fantasy-land/reduce'] = TupleImpl.prototype.reduce;
TupleImpl.prototype['fantasy-land/ap'] = TupleImpl.prototype.ap;
export const Tuple = Object.assign((fst, snd) => new TupleImpl(fst, snd), {
    fromArray: ([fst, snd]) => {
        return Tuple(fst, snd);
    },
    fanout: (...args) => {
        const [f, g, value] = args;
        switch (args.length) {
            case 3:
                return Tuple(f(value), g(value));
            case 2:
                return (value) => Tuple.fanout(f, g, value);
            default:
                return (g) => (value) => Tuple.fanout(f, g, value);
        }
    }
});
TupleImpl.prototype.constructor = Tuple;
